{"meta":{"title":"EndlessCCL","subtitle":"","description":"","author":"CC","url":"https://endlessccl.github.io","root":"/EndlessCCL/"},"pages":[],"posts":[{"title":"transient","slug":"transient","date":"2020-12-11T07:37:06.000Z","updated":"2020-12-14T06:53:35.510Z","comments":true,"path":"2020/12/11/transient/","link":"","permalink":"https://endlessccl.github.io/2020/12/11/transient/","excerpt":"","text":"java序列化Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。 将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 transient的作用和用法当某个或者多个变量或子对象不想被序列化时，使用transient修饰，则java序列化时就不会对其进行序列化。 transient的使用场景： 变量的值可以被推导出来时，比如图像的面积； 敏感信息，比如密码，银行卡账号等； 图片、视频等大文件； 在jdk或者代码中，不可以被序列化的字段。比如没有实现序列化接口不可被序列化的类成员变量，在主类被序列化之前，要标记为transient。 诸如此类不需要或者不想被序列化的信息，都可以用transient来修饰。 1Variables may be marked transient to indicate that they are not part of the persistent state of an object. 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package test;import java.io.*;public class TransientTest &#123; public static void main(String[] args) &#123; User user = new User(&quot;test&quot;, 10, 20); System.out.println(&quot;原始对象: &quot; + user); try &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;./test.out&quot;)); oos.writeObject(user); oos.close(); &#125; catch (FileNotFoundException ex) &#123; ex.printStackTrace(); &#125; catch (IOException ioEx) &#123; ioEx.printStackTrace(); &#125; try &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;./test.out&quot;)); User newUser = (User) ois.readObject(); System.out.println(&quot;序列化再反序列化后的对象: &quot; + newUser); &#125; catch (FileNotFoundException ex) &#123; ex.printStackTrace(); &#125; catch (IOException ioEx) &#123; ioEx.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class User implements Serializable &#123; private String userName; private int age; private transient int anything; User(String userName, int age, int anything) &#123; this.userName = userName; this.age = age; this.anything = anything; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAnything() &#123; return anything; &#125; public void setAnything(int anything) &#123; this.anything = anything; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;userName=&#x27;&quot; + userName + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, anything=&quot; + anything + &#x27;&#125;&#x27;; &#125;&#125; 运行结果为： 12原始对象: User&#123;userName=&#x27;test&#x27;, age=10, anything=20&#125;序列化再反序列化后的对象: User&#123;userName=&#x27;test&#x27;, age=10, anything=0&#125; 可以看到，被transient修饰的anything变量，其值20在序列化的时候并没有被序列化。 transient with final示例代码修改为： 12345private String userName;private int age;private transient int anything;private final transient String confidentialInfo = &quot;password&quot;;private final transient Logger logger = Logger.getLogger(&quot;User&quot;); 运行结果： 12原始对象: User&#123;userName=&#x27;test&#x27;, age=10, anything=20, currentInfo=&#x27;password&#x27;&#125;序列化再反序列化后的对象: User&#123;userName=&#x27;test&#x27;, age=10, anything=0, currentInfo=&#x27;password&#x27;&#125; why？ final修饰的confidentialInfo，是常量，是持久化的。所以是会被序列化到的。final修饰的logger，是引用。 如果将logger的修饰符transient去掉，则会报错： 1234java.io.NotSerializableException: java.util.logging.Logger at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184) at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1548) 所以需要注意，在需要序列化的类中，成员变量如果是不可被序列化的对象的引用，需使用transient修饰。 扩展：HashMap中的transientHashMap源码（1.8）中的片段： 12345678910111213141516171819202122232425262728/*** The table, initialized on first use, and resized as* necessary. When allocated, length is always a power of two.* (We also tolerate length zero in some operations to allow* bootstrapping mechanics that are currently not needed.)*/transient Node&lt;K,V&gt;[] table;/*** Holds cached entrySet(). Note that AbstractMap fields are used* for keySet() and values().*/transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;/*** The number of key-value mappings contained in this map.*/transient int size;/*** The number of times this HashMap has been structurally modified* Structural modifications are those that change the number of mappings in* the HashMap or otherwise modify its internal structure (e.g.,* rehash). This field is used to make iterators on Collection-views of* the HashMap fail-fast. (See ConcurrentModificationException).*/transient int modCount; table，entrySet这些最重要的变量都被transient修饰了，为什么要这么做？HashMap又如何去实现序列化反序列化呢？ 在java中，任何两个实例的hashcode都是不同的，哪怕是同一个类的两个实例。HashMap是被用来存储键值对的，键在HashMap中的位置是是依赖于key的hashcode运算而来的。如果我们对一个HashMap进行序列化，而上边代码中的变量都没被transient修饰的话，则其都会被序列化。当我们进行反序列化的时候，它们也都会被反序列化。比如我们说的key，在这个过程中也会被序列化/反序列化，而序列化/反序列化会丢失一些信息（比如用于计算hashcode），而且，这是一个新的实例了！它的hashcode跟之前的很可能已经不一样了。这样的话，key按照新的hashcode计算的位置不在正确的位置上，当在新的实例上使用key去获取value时，将会得到一个错误的索引。 因此，当哈希映射被序列化时，这意味着哈希索引以及因此而来的表的顺序不再有效，不应该被保留。 那么HashMap是怎么做的呢？writeObject()**，readObject()**。 writeObject1234567891011121314151617181920/*** Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e.,* serialize it).** @serialData The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the* bucket array) is emitted (int), followed by the* &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value* mappings), followed by the key (Object) and value (Object)* for each key-value mapping. The key-value mappings are* emitted in no particular order.*/private void writeObject(java.io.ObjectOutputStream s)throws IOException &#123; int buckets = capacity(); // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); s.writeInt(buckets); s.writeInt(size); internalWriteEntries(s);&#125; 在writeObject的最后，HashMap将其键值对一个个的追加到了字节数组的最后边。注意，这里size被序列化了，是为了后续readObject使用的。 readObject1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Reconstitute the &#123;@code HashMap&#125; instance from a stream (i.e., * deserialize it). */private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125;&#125; 在objectRead的最后，HashMap从字节流的最后一个个把键值对读取出来，然后重新调用putVal()方法，把整个键值对结构重建。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://endlessccl.github.io/tags/java/"}]},{"title":"java中的一些关键字","slug":"java中的一些关键字","date":"2020-12-01T06:30:24.000Z","updated":"2020-12-04T05:54:42.734Z","comments":true,"path":"2020/12/01/java中的一些关键字/","link":"","permalink":"https://endlessccl.github.io/2020/12/01/java%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"volatilevolatile是一个特征修饰符（type specifier）.volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。 原子性：volatile不保证原子性 可见性：volatile保证可见性 有序性：volatile部分保证有序性 volatile关键字禁止指令重排序有两层意思： 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 代码： 相应的汇编代码： count–: volatileCount++: 对比发现，volatile关键字修饰的变量在编译后，会加一个lock指令。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://endlessccl.github.io/tags/java/"},{"name":"学习","slug":"学习","permalink":"https://endlessccl.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"PicGo+GitHub配置图床服务","slug":"PicGo-GitHub配置图床服务","date":"2020-12-01T03:15:29.000Z","updated":"2020-12-01T05:58:36.559Z","comments":true,"path":"2020/12/01/PicGo-GitHub配置图床服务/","link":"","permalink":"https://endlessccl.github.io/2020/12/01/PicGo-GitHub%E9%85%8D%E7%BD%AE%E5%9B%BE%E5%BA%8A%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"前提​ 刚开始使用Hexo+GitHub Pages搭建个人博客，使用typora作为Markdown文件的编辑器。在插入图片时，使用的是本地图片，需要配置一些参数，并且在上传GitHub时也会将图片打包上传。本着爱折腾的性子，上网搜了一下搭建图床的方案，选定了使用GitHub作为图床服务，既然GitHub不限制我们的私有仓库的个数和大小，那就充分利用起来吧。 一 设置GitHub图床服务1.新建仓库​ 新建一个GitHub的仓库，设为public，名字可以根据自己喜好设置。 2.生成token 点击个人头像，选择”settings”，点击进入 点击左侧导航栏”Developer settings”，进入 点击左侧导航栏”Personal access tokens”,点击右上角”Generate new token”,Note可以随意填写，下方选项勾选”repo”，点击”Generate token”生成token，注意，这个token只出现一次，请复制后妥善保存。 3. 配置GitHub Pages参考：官网 二 安装PicGo1.下载安装​ 下载地址：点此下载 根据操作系统，下载相应的包完成后点击安装即可。 2.配置GitHub图床 打开PicGo，点击左侧导航栏”图床设置”，选择”GitHub图床 “ 设定仓库名，你的GitHub账户名/第一步中新建的仓库名，分支选择master，token使用第一步中生成的token，指定存储路径，自定义域名填写配置的GitHub Pages的domain 大功告成，开始新的折腾。","categories":[],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"https://endlessccl.github.io/tags/PicGo/"},{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"https://endlessccl.github.io/tags/GitHub-Pages/"}]},{"title":"个人随笔","slug":"hello-world","date":"2020-11-30T07:02:18.345Z","updated":"2020-12-01T02:44:09.405Z","comments":true,"path":"2020/11/30/hello-world/","link":"","permalink":"https://endlessccl.github.io/2020/11/30/hello-world/","excerpt":"","text":"学的知识点 遇到的问题以及解决","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://endlessccl.github.io/tags/java/"},{"name":"学习","slug":"学习","permalink":"https://endlessccl.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"PicGo","slug":"PicGo","permalink":"https://endlessccl.github.io/tags/PicGo/"},{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"https://endlessccl.github.io/tags/GitHub-Pages/"}]}