{"meta":{"title":"EndlessCCL","subtitle":"","description":"","author":"CC","url":"https://endlessccl.github.io","root":"/EndlessCCL/"},"pages":[],"posts":[{"title":"Nacos","slug":"Nacos","date":"2020-12-17T05:58:32.000Z","updated":"2020-12-17T07:57:21.202Z","comments":true,"path":"2020/12/17/Nacos/","link":"","permalink":"https://endlessccl.github.io/2020/12/17/Nacos/","excerpt":"","text":"Nacos是什么 Nacos官网的描述定义： 12Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。 简单的理解，Nacos相当于注册中心和配置中心。 Nacos 的关键特性包括: 服务发现和服务健康监测 Nacos 支持基于 DNS 和基于 RPC 的服务发现。服务提供者使用 原生SDK、OpenAPI、或一个独立的Agent TODO注册 Service 后，服务消费者可以使用DNS TODO 或HTTP&amp;API查找和发现服务。 Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。 动态配置服务 动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。 动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。 配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。 Nacos 提供了一个简洁易用的UI (控制台样例 Demo) 帮助您管理所有的服务和应用的配置。Nacos 还提供包括配置版本跟踪、金丝雀发布、一键回滚配置以及客户端配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助您更安全地在生产环境中管理配置变更和降低配置变更带来的风险。 动态 DNS 服务 动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务。动态DNS服务还能让您更容易地实现以 DNS 协议为基础的服务发现，以帮助您消除耦合到厂商私有服务发现 API 上的风险。 Nacos 提供了一些简单的 DNS APIs TODO 帮助您管理服务的关联域名和可用的 IP:PORT 列表. 服务及其元数据管理 Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据。 Nacos作为注册中心的实现 0.demo架构设计 1.启动Nacos-serverNacos-server可以直接从github上下载安装包，当然你也可以拉取代码后自行打包。 下载地址： https://github.com/alibaba/nacos/releases 下载解压后进入bin文件夹（目录：nacos-server-1.0.1\\nacos\\bin），直接双击执行startup.cmd文件 启动成功后，输入127.0.0.1:8848/nacos进入控制台，默认用户名密码为 nacos/nacos。 2.创建nacos-provider创建spring-boot工程，pom文件引入nacos需要的依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 在项目启动类上添加@EnableDiscoveryClient 注解，开启服务发现功能。 配置文件中加入： 1234567spring: application: name: nacos-provider cloud: nacos: discovery: server-addr: 127.0.0.1:8848 提供一个对外接口，代码示例如下： 1234@GetMapping(&quot;/helloNacos&quot;)public String helloNacos()&#123; return &quot;你好，nacos！&quot;;&#125; 启动项目，nacos控制台–服务管理–服务列表可以看到服务注册成功。 3.创建nacos-consumerpom引入和配置同上，这里采用RestTemplate+Ribbon进行服务间调用，nacos-consumer启动类添加@EnableDiscoveryClient注解，接口和调用示例代码如下： 1234567891011121314@Autowiredprivate RestTemplate restTemplate;@Bean@LoadBalancedpublic RestTemplate getRestTemplate()&#123; return new RestTemplate();&#125;@GetMapping(&quot;/consumer&quot;)public String test1() &#123; String result = restTemplate.getForObject(&quot;http://nacos-provide/helloNacos&quot;,String.class); return &quot;Return : &quot; + result;&#125; 启动项目。 4.测试打开postman，调用nacos-consumer /consumer接口，返回 Return : 你好，nacos! 5.使用openfeign进行服务间调用nacos-consumer pom引入： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 启动类添加@EnableFeignClients 注解 编写远程调用服务接口，示例代码如下： 12345@FeignClient(name = &quot;nacos-provide&quot;,fallback = RemoteClientFallback.class)public interface RemoteClient &#123; @GetMapping(&quot;/helloNacos&quot;) String helloNacos();&#125; RemoteClientFallback代码： 1234567@Componentpublic class RemoteClientFallback implements RemoteClient &#123; @Override public String helloNacos() &#123; return &quot;请求超时了&quot;; &#125;&#125; openfeign调用示例代码： 1234567@AutoWiredprivate RemoteClient remoteClient;@GetMapping(&quot;/consumer2&quot;)public String test2() &#123; return remoteClient.helloNacos();&#125;","categories":[],"tags":[{"name":"Nacos","slug":"Nacos","permalink":"https://endlessccl.github.io/tags/Nacos/"},{"name":"Spring Cloud Alibaba","slug":"Spring-Cloud-Alibaba","permalink":"https://endlessccl.github.io/tags/Spring-Cloud-Alibaba/"},{"name":"注册中心","slug":"注册中心","permalink":"https://endlessccl.github.io/tags/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"}]},{"title":"transient","slug":"transient","date":"2020-12-11T07:37:06.000Z","updated":"2020-12-16T08:46:56.725Z","comments":true,"path":"2020/12/11/transient/","link":"","permalink":"https://endlessccl.github.io/2020/12/11/transient/","excerpt":"","text":"java序列化Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。 将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 transient的作用和用法当某个或者多个变量或子对象不想被序列化时，使用transient修饰，则java序列化时就不会对其进行序列化。 transient的使用场景： 变量的值可以被推导出来时，比如图像的面积； 敏感信息，比如密码，银行卡账号等； 图片、视频等大文件； 在jdk或者代码中，不可以被序列化的字段。比如没有实现序列化接口不可被序列化的类成员变量，在主类被序列化之前，要标记为transient。 诸如此类不需要或者不想被序列化的信息，都可以用transient来修饰。 1Variables may be marked transient to indicate that they are not part of the persistent state of an object. 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package test;import java.io.*;public class TransientTest &#123; public static void main(String[] args) &#123; User user = new User(&quot;test&quot;, 10, 20); System.out.println(&quot;原始对象: &quot; + user); try &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;./test.out&quot;)); oos.writeObject(user); oos.close(); &#125; catch (FileNotFoundException ex) &#123; ex.printStackTrace(); &#125; catch (IOException ioEx) &#123; ioEx.printStackTrace(); &#125; try &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;./test.out&quot;)); User newUser = (User) ois.readObject(); System.out.println(&quot;序列化再反序列化后的对象: &quot; + newUser); &#125; catch (FileNotFoundException ex) &#123; ex.printStackTrace(); &#125; catch (IOException ioEx) &#123; ioEx.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class User implements Serializable &#123; private String userName; private int age; private transient int anything; User(String userName, int age, int anything) &#123; this.userName = userName; this.age = age; this.anything = anything; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAnything() &#123; return anything; &#125; public void setAnything(int anything) &#123; this.anything = anything; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;userName=&#x27;&quot; + userName + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, anything=&quot; + anything + &#x27;&#125;&#x27;; &#125;&#125; 运行结果为： 12原始对象: User&#123;userName=&#x27;test&#x27;, age=10, anything=20&#125;序列化再反序列化后的对象: User&#123;userName=&#x27;test&#x27;, age=10, anything=0&#125; 可以看到，被transient修饰的anything变量，其值20在序列化的时候并没有被序列化。 transient with final示例代码修改为： 12345private String userName;private int age;private transient int anything;private final transient String confidentialInfo = &quot;password&quot;;private final transient Logger logger = Logger.getLogger(&quot;User&quot;); 运行结果： 12原始对象: User&#123;userName=&#x27;test&#x27;, age=10, anything=20, currentInfo=&#x27;password&#x27;&#125;序列化再反序列化后的对象: User&#123;userName=&#x27;test&#x27;, age=10, anything=0, currentInfo=&#x27;password&#x27;&#125; why？ final修饰的confidentialInfo，是常量，是持久化的。所以是会被序列化到的。final修饰的logger，是引用。 如果将logger的修饰符transient去掉，则会报错： 1234java.io.NotSerializableException: java.util.logging.Logger at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184) at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1548) 所以需要注意，在需要序列化的类中，成员变量如果是不可被序列化的对象的引用，需使用transient修饰。 扩展：HashMap中的transientHashMap源码（1.8）中的片段： 12345678910111213141516171819202122232425262728/*** The table, initialized on first use, and resized as* necessary. When allocated, length is always a power of two.* (We also tolerate length zero in some operations to allow* bootstrapping mechanics that are currently not needed.)*/transient Node&lt;K,V&gt;[] table;/*** Holds cached entrySet(). Note that AbstractMap fields are used* for keySet() and values().*/transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;/*** The number of key-value mappings contained in this map.*/transient int size;/*** The number of times this HashMap has been structurally modified* Structural modifications are those that change the number of mappings in* the HashMap or otherwise modify its internal structure (e.g.,* rehash). This field is used to make iterators on Collection-views of* the HashMap fail-fast. (See ConcurrentModificationException).*/transient int modCount; table，entrySet这些最重要的变量都被transient修饰了，为什么要这么做？HashMap又如何去实现序列化反序列化呢？ 在java中，任何两个实例的hashcode都是不同的，哪怕是同一个类的两个实例。HashMap是被用来存储键值对的，键在HashMap中的位置是是依赖于key的hashcode运算而来的。如果我们对一个HashMap进行序列化，而上边代码中的变量都没被transient修饰的话，则其都会被序列化。当我们进行反序列化的时候，它们也都会被反序列化。比如我们说的key，在这个过程中也会被序列化/反序列化，而序列化/反序列化会丢失一些信息（比如用于计算hashcode），而且，这是一个新的实例了！它的hashcode跟之前的很可能已经不一样了。这样的话，key按照新的hashcode计算的位置不在正确的位置上，当在新的实例上使用key去获取value时，将会得到一个错误的索引。 因此，当哈希映射被序列化时，这意味着哈希索引以及因此而来的表的顺序不再有效，不应该被保留。 那么HashMap是怎么做的呢？writeObject()**，readObject()**。 writeObject1234567891011121314151617181920/*** Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e.,* serialize it).** @serialData The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the* bucket array) is emitted (int), followed by the* &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value* mappings), followed by the key (Object) and value (Object)* for each key-value mapping. The key-value mappings are* emitted in no particular order.*/private void writeObject(java.io.ObjectOutputStream s)throws IOException &#123; int buckets = capacity(); // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); s.writeInt(buckets); s.writeInt(size); internalWriteEntries(s);&#125; 在writeObject的最后，HashMap将其键值对一个个的追加到了字节数组的最后边。注意，这里size被序列化了，是为了后续readObject使用的。 readObject1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Reconstitute the &#123;@code HashMap&#125; instance from a stream (i.e., * deserialize it). */private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125;&#125; 在objectRead的最后，HashMap从字节流的最后一个个把键值对读取出来，然后重新调用putVal()方法，把整个键值对结构重建。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://endlessccl.github.io/tags/java/"}]},{"title":"java中的一些关键字","slug":"java中的一些关键字","date":"2020-12-01T06:30:24.000Z","updated":"2020-12-04T05:54:42.734Z","comments":true,"path":"2020/12/01/java中的一些关键字/","link":"","permalink":"https://endlessccl.github.io/2020/12/01/java%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"volatilevolatile是一个特征修饰符（type specifier）.volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。 原子性：volatile不保证原子性 可见性：volatile保证可见性 有序性：volatile部分保证有序性 volatile关键字禁止指令重排序有两层意思： 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 代码： 相应的汇编代码： count–: volatileCount++: 对比发现，volatile关键字修饰的变量在编译后，会加一个lock指令。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://endlessccl.github.io/tags/java/"},{"name":"学习","slug":"学习","permalink":"https://endlessccl.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"PicGo+GitHub配置图床服务","slug":"PicGo-GitHub配置图床服务","date":"2020-12-01T03:15:29.000Z","updated":"2020-12-01T05:58:36.559Z","comments":true,"path":"2020/12/01/PicGo-GitHub配置图床服务/","link":"","permalink":"https://endlessccl.github.io/2020/12/01/PicGo-GitHub%E9%85%8D%E7%BD%AE%E5%9B%BE%E5%BA%8A%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"前提​ 刚开始使用Hexo+GitHub Pages搭建个人博客，使用typora作为Markdown文件的编辑器。在插入图片时，使用的是本地图片，需要配置一些参数，并且在上传GitHub时也会将图片打包上传。本着爱折腾的性子，上网搜了一下搭建图床的方案，选定了使用GitHub作为图床服务，既然GitHub不限制我们的私有仓库的个数和大小，那就充分利用起来吧。 一 设置GitHub图床服务1.新建仓库​ 新建一个GitHub的仓库，设为public，名字可以根据自己喜好设置。 2.生成token 点击个人头像，选择”settings”，点击进入 点击左侧导航栏”Developer settings”，进入 点击左侧导航栏”Personal access tokens”,点击右上角”Generate new token”,Note可以随意填写，下方选项勾选”repo”，点击”Generate token”生成token，注意，这个token只出现一次，请复制后妥善保存。 3. 配置GitHub Pages参考：官网 二 安装PicGo1.下载安装​ 下载地址：点此下载 根据操作系统，下载相应的包完成后点击安装即可。 2.配置GitHub图床 打开PicGo，点击左侧导航栏”图床设置”，选择”GitHub图床 “ 设定仓库名，你的GitHub账户名/第一步中新建的仓库名，分支选择master，token使用第一步中生成的token，指定存储路径，自定义域名填写配置的GitHub Pages的domain 大功告成，开始新的折腾。","categories":[],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"https://endlessccl.github.io/tags/PicGo/"},{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"https://endlessccl.github.io/tags/GitHub-Pages/"}]},{"title":"个人随笔","slug":"hello-world","date":"2020-11-30T07:02:18.345Z","updated":"2020-12-01T02:44:09.405Z","comments":true,"path":"2020/11/30/hello-world/","link":"","permalink":"https://endlessccl.github.io/2020/11/30/hello-world/","excerpt":"","text":"学的知识点 遇到的问题以及解决","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Nacos","slug":"Nacos","permalink":"https://endlessccl.github.io/tags/Nacos/"},{"name":"Spring Cloud Alibaba","slug":"Spring-Cloud-Alibaba","permalink":"https://endlessccl.github.io/tags/Spring-Cloud-Alibaba/"},{"name":"注册中心","slug":"注册中心","permalink":"https://endlessccl.github.io/tags/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"},{"name":"java","slug":"java","permalink":"https://endlessccl.github.io/tags/java/"},{"name":"学习","slug":"学习","permalink":"https://endlessccl.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"PicGo","slug":"PicGo","permalink":"https://endlessccl.github.io/tags/PicGo/"},{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"https://endlessccl.github.io/tags/GitHub-Pages/"}]}